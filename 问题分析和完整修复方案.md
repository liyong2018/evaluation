# 问题分析和完整修复方案

## 问题现象

在"模型评估结果 - 计算结果"弹窗中，各步骤的输出列没有正确分组：
- 步骤1的8个列被归到了"其他输出"中
- 其他步骤的列数也不正确

## 根本原因

**后端返回的数据没有包含 `columns` 字段，前端无法确定每一列属于哪个步骤。**

具体问题：

1. **后端问题**：
   - `executeAlgorithmStep` 方法返回的数据只有 `tableData`，没有 `columns`
   - `executeModel` 方法返回的数据也没有 `columns`
   - 前端无法知道每一列的 `stepOrder`（步骤序号）

2. **前端问题**（已修复）：
   - 即使后端返回了 `columns`，前端在初始化列时没有保留 `stepOrder` 字段
   - 已在 `ResultDialog.vue` 第702行添加了 `stepOrder: (col as any).stepOrder`

## 完整修复方案

### 第一步：修改后端代码

#### 1.1 修改 `executeAlgorithmStep` 方法

**文件**：`src/main/java/com/evaluate/service/impl/ModelExecutionServiceImpl.java`

**位置**：约第535-547行

**修改内容**：

```java
// 5. 生成该步骤的2D表格数据
List<Map<String, Object>> tableData = generateStepResultTable(stepExecutionResult, regionCodes);

// ==================== 新增：生成 columns 数组 ====================
List<Map<String, Object>> columns = generateColumnsWithStepOrder(tableData, stepOrder);
// =================================================================

// 6. 构建返回结果
Map<String, Object> result = new HashMap<>();
result.put("stepId", targetStep.getId());
result.put("stepName", targetStep.getStepName());
result.put("stepOrder", stepOrder);
result.put("stepCode", targetStep.getStepCode());
result.put("description", targetStep.getStepDescription());
result.put("executionResult", stepExecutionResult);
result.put("tableData", tableData);
result.put("columns", columns);  // 新增这一行
result.put("success", true);
result.put("executionTime", new Date());
```

#### 1.2 添加辅助方法 `generateColumnsWithStepOrder`

**文件**：`src/main/java/com/evaluate/service/impl/ModelExecutionServiceImpl.java`

**位置**：在类的末尾（约第887行之前），添加以下方法：

```java
/**
 * 从表格数据生成 columns 数组，并为非基础列添加 stepOrder
 * 
 * @param tableData 表格数据
 * @param stepOrder 当前步骤序号
 * @return columns 数组
 */
private List<Map<String, Object>> generateColumnsWithStepOrder(
        List<Map<String, Object>> tableData, Integer stepOrder) {
    
    List<Map<String, Object>> columns = new ArrayList<>();
    
    if (tableData == null || tableData.isEmpty()) {
        log.debug("表格数据为空，返回空的 columns 数组");
        return columns;
    }
    
    // 从第一行数据提取所有列名
    Map<String, Object> firstRow = tableData.get(0);
    Set<String> baseColumns = new HashSet<>(Arrays.asList("regionCode", "regionName", "region"));
    
    log.info("开始生成 columns 数组，步骤序号: {}, 列数: {}", stepOrder, firstRow.size());
    
    for (String columnName : firstRow.keySet()) {
        Map<String, Object> column = new LinkedHashMap<>();
        column.put("prop", columnName);
        column.put("label", columnName);  // 使用中文名称作为 label
        
        // 设置列宽
        if ("regionCode".equals(columnName)) {
            column.put("width", 150);
        } else if ("regionName".equals(columnName) || "region".equals(columnName)) {
            column.put("width", 120);
        } else {
            column.put("width", 120);
            // 非基础列添加 stepOrder
            column.put("stepOrder", stepOrder);
            log.debug("列 {} 标记为步骤 {}", columnName, stepOrder);
        }
        
        columns.add(column);
    }
    
    log.info("完成 columns 数组生成，共 {} 列，其中 {} 列包含 stepOrder", 
            columns.size(), columns.stream().filter(c -> c.containsKey("stepOrder")).count());
    
    return columns;
}
```

#### 1.3 添加必要的导入语句

**文件**：`src/main/java/com/evaluate/service/impl/ModelExecutionServiceImpl.java`

**位置**：文件顶部的 import 区域

**添加内容**：

```java
import java.util.Arrays;
import java.util.Collections;
```

### 第二步：验证前端代码（已完成）

前端代码已经修改完成：

**文件**：`frontend/src/components/ResultDialog.vue`

**修改位置**：第702行

**修改内容**：添加了 `stepOrder: (col as any).stepOrder`，确保从后端接收的 stepOrder 字段被保留。

### 第三步：测试验证

#### 3.1 编译和启动后端

```bash
# 在后端项目根目录执行
mvn clean package
java -jar target/evaluation-*.jar
```

#### 3.2 启动前端

```bash
# 在前端目录执行
npm run dev
```

#### 3.3 测试步骤

1. 打开浏览器开发者工具（F12）
2. 进入"评估管理"页面
3. 选择模型和地区，点击"执行算法步骤"
4. 在"计算结果"弹窗中，观察列的分组情况
5. 查看浏览器控制台日志

#### 3.4 预期的日志输出

前端控制台应该显示：

```
=== 开始计算列分组 ===
Computing column groups with: {
  allColumnsCount: 10,
  allColumnsList: [
    { prop: 'regionCode', label: '地区代码', stepOrder: undefined },
    { prop: 'regionName', label: '地区名称', stepOrder: undefined },
    { prop: '队伍管理能力计算', label: '队伍管理能力计算', stepOrder: 1 },
    { prop: '风险评估能力计算', label: '风险评估能力计算', stepOrder: 1 },
    ...
  ],
  ...
}

检测到列数据中包含stepOrder字段，使用该字段进行分组

✓ 添加分组(从列数据): 步骤1 评估指标赋值 共 8 列

=== 列分组完成 ===
```

后端日志应该显示：

```
开始生成 columns 数组，步骤序号: 1, 列数: 10
列 队伍管理能力计算 标记为步骤 1
列 风险评估能力计算 标记为步骤 1
...
完成 columns 数组生成，共 10 列，其中 8 列包含 stepOrder
```

#### 3.5 验证结果

在"计算结果"弹窗中应该看到：

- ✅ **基础信息**：2列（地区代码、地区名称）
- ✅ **步骤1 评估指标赋值**：8列（队伍管理能力计算、风险评估能力计算等）
- ✅ **其他输出**：0列（或者这个分组不出现）

### 第四步：扩展到模型执行（可选）

如果需要在执行完整模型时也显示分组，可以修改 `executeModel` 方法。详细步骤请参考 `后端修改方案-添加columns字段.md` 中的"方案 2"。

## 代码修改对比

### 后端修改（核心）

```diff
@@ -532,6 +532,10 @@
         // 5. 生成该步骤的2D表格数据
         List<Map<String, Object>> tableData = generateStepResultTable(stepExecutionResult, regionCodes);

+        // 生成 columns 数组
+        List<Map<String, Object>> columns = generateColumnsWithStepOrder(tableData, stepOrder);
+
         // 6. 构建返回结果
         Map<String, Object> result = new HashMap<>();
         result.put("stepId", targetStep.getId());
@@ -541,6 +545,7 @@
         result.put("description", targetStep.getStepDescription());
         result.put("executionResult", stepExecutionResult);
         result.put("tableData", tableData);
+        result.put("columns", columns);
         result.put("success", true);
         result.put("executionTime", new Date());

@@ -877,6 +882,48 @@
         return tableData;
     }

+    /**
+     * 从表格数据生成 columns 数组，并为非基础列添加 stepOrder
+     */
+    private List<Map<String, Object>> generateColumnsWithStepOrder(
+            List<Map<String, Object>> tableData, Integer stepOrder) {
+        
+        List<Map<String, Object>> columns = new ArrayList<>();
+        
+        if (tableData == null || tableData.isEmpty()) {
+            log.debug("表格数据为空，返回空的 columns 数组");
+            return columns;
+        }
+        
+        Map<String, Object> firstRow = tableData.get(0);
+        Set<String> baseColumns = new HashSet<>(Arrays.asList("regionCode", "regionName", "region"));
+        
+        log.info("开始生成 columns 数组，步骤序号: {}, 列数: {}", stepOrder, firstRow.size());
+        
+        for (String columnName : firstRow.keySet()) {
+            Map<String, Object> column = new LinkedHashMap<>();
+            column.put("prop", columnName);
+            column.put("label", columnName);
+            
+            if ("regionCode".equals(columnName)) {
+                column.put("width", 150);
+            } else if ("regionName".equals(columnName) || "region".equals(columnName)) {
+                column.put("width", 120);
+            } else {
+                column.put("width", 120);
+                column.put("stepOrder", stepOrder);
+                log.debug("列 {} 标记为步骤 {}", columnName, stepOrder);
+            }
+            
+            columns.add(column);
+        }
+        
+        log.info("完成 columns 数组生成，共 {} 列，其中 {} 列包含 stepOrder", 
+                columns.size(), columns.stream().filter(c -> c.containsKey("stepOrder")).count());
+        
+        return columns;
+    }
+
     @Autowired
     private AlgorithmStepMapper algorithmStepMapper;
```

### 前端修改（已完成）

```diff
@@ -695,11 +695,12 @@
     if (columnsFromProps.length > 0) {
-      // 直接使用 props.columns，保留已有label/width/formatter
+      // 直接使用 props.columns，保留已有label/width/formatter/stepOrder
       allColumns.value = columnsFromProps.map(col => ({
         prop: col.prop,
         label: col.label || getColumnLabel(col.prop),
         width: col.width || getColumnWidth(col.prop),
-        formatter: col.formatter
+        formatter: col.formatter,
+        stepOrder: (col as any).stepOrder  // 保留 stepOrder 字段
       }))
       visibleColumns.value = allColumns.value.map(col => col.prop)
       console.log('Columns initialized from props (single-table):', {
         totalColumns: allColumns.value.length,
-        visibleColumns: visibleColumns.value.length
+        visibleColumns: visibleColumns.value.length,
+        columnsWithStepOrder: allColumns.value.filter(c => (c as any).stepOrder).length
       })
       return
     }
```

## 为什么之前的方案没有生效

之前提供的后端代码示例（`后端代码示例-添加stepOrder.java`）是正确的，但是：

1. **没有实际应用到项目代码中**：示例文件只是一个参考，需要将其中的代码整合到实际的 `ModelExecutionServiceImpl.java` 文件中。

2. **前端有个小bug**：即使后端返回了正确的数据，前端在映射 columns 时会丢失 `stepOrder` 字段（现在已修复）。

## 关键要点

1. **数据驱动**：后端明确标记每一列属于哪个步骤（通过 `stepOrder` 字段）
2. **前端保留**：前端接收并保留这个字段，用于分组逻辑
3. **向后兼容**：基础列（regionCode, regionName）不包含 `stepOrder` 字段，自动归入"基础信息"分组
4. **日志验证**：通过详细的日志输出，可以快速定位问题

## 下一步

1. 按照上述步骤修改后端代码
2. 重新编译和启动服务
3. 测试验证功能是否正常
4. 如有问题，查看日志进行调试

修改后的效果应该是：每个步骤的列都正确归类，不再出现"其他输出"包含大量列的情况。
