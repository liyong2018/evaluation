# 乡镇聚合真正修复总结

## 问题分析

### 原问题
1. **列名对不上**：步骤2输出 `TOWNSHIP_PLAN_AGG` 等字段，但步骤3需要 `PLAN_CONSTRUCTION` 等字段
2. **没有真正聚合**：步骤2只是简单传递社区数据，没有按乡镇分组求和

### 根本原因
- 当前的执行框架是按 `regionCode`（社区代码）循环的
- 没有按乡镇分组聚合的逻辑
- 输出字段名与后续步骤的输入字段名不匹配

## 解决方案

### 1. 后端代码修改

**文件**: `src/main/java/com/evaluate/service/impl/ModelExecutionServiceImpl.java`

#### 修改1：在executeModel中添加AGGREGATION类型的特殊处理
```java
// 特殊处理：如果是AGGREGATION类型且modelId=8，执行乡镇聚合
if ("AGGREGATION".equals(step.getStepType()) && modelId == 8) {
    log.info("检测到乡镇聚合步骤，执行按乡镇分组聚合");
    stepResult = executeTownshipAggregation(step.getId(), regionCodes, globalContext);
} else {
    // 执行单个步骤
    stepResult = executeStep(step.getId(), regionCodes, globalContext);
}
```

#### 修改2：添加executeTownshipAggregation方法
实现真正的乡镇聚合逻辑：
1. 按 `township_name` 分组收集社区数据
2. 对每个乡镇的社区数据求和
3. 除以社区数量得到平均值
4. 使用乡镇的第一个社区代码作为key（保持与后续步骤兼容）

**聚合公式**：
```
乡镇能力平均值 = SUM(社区能力值) / 社区数量
```

#### 修改3：添加toDouble辅助方法
用于类型转换

### 2. 数据库配置修改

**文件**: `fix_township_output_params.sql`

修改步骤2的输出参数名称，使其与步骤3的输入参数名称匹配：

| 算法ID | 原输出参数名 | 新输出参数名 | 说明 |
|--------|-------------|-------------|------|
| 1752 | TOWNSHIP_PLAN_AGG | PLAN_CONSTRUCTION | 预案编制能力 |
| 1753 | TOWNSHIP_HAZARD_AGG | HAZARD_INSPECTION | 隐患排查能力 |
| 1754 | TOWNSHIP_RISK_AGG | RISK_ASSESSMENT | 风险评估能力 |
| 1755 | TOWNSHIP_FINANCIAL_AGG | FINANCIAL_INPUT | 资金投入能力 |
| 1756 | TOWNSHIP_MATERIAL_AGG | MATERIAL_RESERVE | 物资储备能力 |
| 1757 | TOWNSHIP_MEDICAL_AGG | MEDICAL_SUPPORT | 医疗保障能力 |
| 1758 | TOWNSHIP_AID_AGG | SELF_MUTUAL_AID | 自救互救能力 |
| 1759 | TOWNSHIP_EVACUATION_AGG | PUBLIC_EVACUATION | 公众疏散能力 |
| 1760 | TOWNSHIP_SHELTER_AGG | RELOCATION_SHELTER | 转移安置能力 |

**执行状态**: ✅ 已执行

## 执行流程

### 步骤1：社区指标计算
- 输入：社区原始数据（从 `community_disaster_reduction_capacity` 表）
- 处理：计算9个能力值
- 输出：社区级别的能力值（PLAN_CONSTRUCTION, HAZARD_INSPECTION, ...）

### 步骤2：乡镇数据聚合（新实现）
- 输入：步骤1的社区级别能力值
- 处理：
  1. 按 `township_name` 分组
  2. 对每个乡镇的社区数据求和
  3. 除以社区数量得到平均值
- 输出：乡镇级别的能力平均值（使用相同的字段名：PLAN_CONSTRUCTION, HAZARD_INSPECTION, ...）

### 步骤3：属性向量归一化
- 输入：步骤2的乡镇级别能力值（PLAN_CONSTRUCTION, HAZARD_INSPECTION, ...）
- 处理：归一化
- 输出：归一化后的值

### 步骤4-6：后续TOPSIS计算
- 继续使用归一化后的值进行计算

## 数据流示意图

```
社区原始数据 (community_disaster_reduction_capacity)
  ↓
步骤1: 社区指标计算
  ↓ 输出: PLAN_CONSTRUCTION, HAZARD_INSPECTION, ... (社区级别)
步骤2: 乡镇数据聚合 (executeTownshipAggregation)
  ↓ 按township_name分组
  ↓ 求和 / 社区数量
  ↓ 输出: PLAN_CONSTRUCTION, HAZARD_INSPECTION, ... (乡镇级别)
步骤3: 属性向量归一化
  ↓ 输入: PLAN_CONSTRUCTION, HAZARD_INSPECTION, ...
  ↓ 输出: PLAN_CONSTRUCTION_NORM, HAZARD_INSPECTION_NORM, ...
步骤4-6: TOPSIS计算
  ↓
最终结果: 乡镇级别的综合减灾能力评估
```

## 关键改进

### 1. 真正的乡镇聚合
- ✅ 按 `township_name` 分组
- ✅ 对每个乡镇的社区数据求和
- ✅ 除以社区数量得到平均值

### 2. 字段名匹配
- ✅ 步骤2输出字段名与步骤3输入字段名一致
- ✅ 数据流畅通无阻

### 3. 保持兼容性
- ✅ 使用乡镇的第一个社区代码作为key
- ✅ 后续步骤无需修改

## 测试步骤

### 1. 重启后端服务
```bash
# 停止当前服务
# 重新启动服务
```

### 2. 准备测试数据
确保数据库中有多个社区属于同一个乡镇，例如：
- 社区A (511425108001) - 属于瑞峰镇
- 社区B (511425108002) - 属于瑞峰镇
- 社区C (511425108003) - 属于瑞峰镇

### 3. 执行模型8
```bash
POST /api/model/execute
{
  "modelId": 8,
  "regionCodes": ["511425108001", "511425108002", "511425108003"],
  "weightConfigId": 1
}
```

### 4. 验证结果
检查返回的数据：
- ✅ 只有1行数据（乡镇级别）
- ✅ 字段名正确（PLAN_CONSTRUCTION, HAZARD_INSPECTION, ...）
- ✅ 值是3个社区的平均值
- ✅ 包含 `townshipName` 字段

### 5. 查看日志
检查后端日志中的聚合信息：
```
检测到乡镇聚合步骤，执行按乡镇分组聚合
按乡镇分组完成，共 1 个乡镇
处理乡镇: 瑞峰镇, 社区数量: 3
乡镇 瑞峰镇 的 PLAN_CONSTRUCTION 聚合结果: sum=X, count=3, avg=Y
...
乡镇聚合完成，共 1 个乡镇
```

## 预期结果

### 输入（3个社区）
| 社区代码 | 乡镇 | PLAN_CONSTRUCTION |
|---------|------|-------------------|
| 511425108001 | 瑞峰镇 | 0.5 |
| 511425108002 | 瑞峰镇 | 0.6 |
| 511425108003 | 瑞峰镇 | 0.7 |

### 输出（1个乡镇）
| 社区代码 | 乡镇 | PLAN_CONSTRUCTION |
|---------|------|-------------------|
| 511425108001 | 瑞峰镇 | 0.6 (平均值) |

**计算过程**：
```
sum = 0.5 + 0.6 + 0.7 = 1.8
count = 3
average = 1.8 / 3 = 0.6
```

## 相关文件

- ✅ `ModelExecutionServiceImpl.java` - 后端代码修改（已完成）
- ✅ `fix_township_output_params.sql` - 数据库修改脚本（已执行）
- 📄 `test_township_aggregation.ps1` - 测试脚本
- 📄 `乡镇聚合实现方案.md` - 详细方案分析

## 下一步

1. **重启后端服务** - 使代码修改生效
2. **执行测试** - 验证乡镇聚合功能
3. **检查日志** - 确认聚合逻辑正确执行
4. **验证数据** - 确认输出的是乡镇级别的平均值

## 注意事项

1. **社区必须有township_name**：如果社区数据中没有 `township_name` 字段，该社区会被跳过
2. **使用第一个社区代码**：每个乡镇使用其第一个社区的 `region_code` 作为标识
3. **保持字段名一致**：步骤2的输出字段名必须与步骤3的输入字段名一致
4. **只对modelId=8生效**：乡镇聚合逻辑只在模型8中启用，不影响其他模型
