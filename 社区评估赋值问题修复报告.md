# 社区评估模型赋值问题修复报告

## 问题描述

社区评估模型的结果中，多个评估指标的赋值为 0，包括：
- 预案编制能力赋值
- 隐患排查能力赋值
- 风险评估能力赋值
- 财政投入能力赋值
- 物资储备能力赋值
- 医疗保障能力赋值
- 自救互救能力赋值
- 公众疏散能力赋值
- 转移安置能力赋值

## 问题原因

### 根本原因：变量名不匹配

**算法表达式中使用的变量名**（数据库字段名，下划线命名）：
```
last_year_funding_amount
resident_population
materials_equipment_value
has_emergency_plan
militia_reserve_count
registered_volunteer_count
...等等
```

**原代码中设置的变量名**（Java驼峰命名）：
```java
context.put("lastYearFundingAmount", fundingAmount);  // ❌ 不匹配
context.put("residentPopulation", residentPopulation);  // ❌ 不匹配
context.put("materialsEquipmentValue", materialValue);  // ❌ 不匹配
context.put("hasEmergencyPlan", communityData.getHasEmergencyPlan());  // ❌ 不匹配
...
```

由于变量名不匹配，QLExpress 表达式计算时找不到对应的变量，导致计算结果为 0。

### 架构问题

原代码存在硬编码问题：
1. 在 `addCommunityDataToContext` 方法中手动将每个字段从实体对象转换并添加到上下文
2. 每次添加新字段都需要修改代码
3. 容易出现变量名不一致的问题

## 解决方案

### 核心思路

**算法表达式中配置什么变量名，就直接使用数据库字段名**，无需在代码中进行映射。

### 具体修改

#### 1. 使用 `selectMaps` 查询返回 Map

**修改前**：
```java
CommunityDisasterReductionCapacity communityData = communityDataMapper.selectOne(communityQuery);
if (communityData != null) {
    addCommunityDataToContext(regionContext, communityData);
}
```

**修改后**：
```java
// 使用selectMaps直接返回Map，key为数据库字段名，可直接匹配算法表达式中的变量名
List<Map<String, Object>> communityDataList = communityDataMapper.selectMaps(communityQuery);
if (communityDataList != null && !communityDataList.isEmpty()) {
    Map<String, Object> communityDataMap = communityDataList.get(0);
    addMapDataToContext(regionContext, communityDataMap);
}
```

#### 2. 创建通用的 `addMapDataToContext` 方法

```java
/**
 * 通用方法：将Map数据添加到上下文
 * 数据库字段名直接作为变量名，无需手动映射
 * 所有数值类型转换为Double，避免整数除法精度丢失
 */
private void addMapDataToContext(Map<String, Object> context, Map<String, Object> dataMap) {
    if (dataMap == null || dataMap.isEmpty()) {
        return;
    }

    for (Map.Entry<String, Object> entry : dataMap.entrySet()) {
        String key = entry.getKey();
        Object value = entry.getValue();

        // 跳过时间字段和ID字段
        if ("create_time".equals(key) || "update_time".equals(key) || "id".equals(key)) {
            continue;
        }

        // 转换数值类型为Double，避免整数除法精度丢失
        Object contextValue = value;
        if (value != null) {
            if (value instanceof Integer) {
                contextValue = ((Integer) value).doubleValue();
            } else if (value instanceof Long) {
                contextValue = ((Long) value).doubleValue();
            } else if (value instanceof java.math.BigDecimal) {
                contextValue = ((java.math.BigDecimal) value).doubleValue();
            } else if (value instanceof Float) {
                contextValue = ((Float) value).doubleValue();
            }
        }

        // 直接使用数据库字段名作为上下文变量名
        context.put(key, contextValue);
    }

    log.debug("成功将 {} 个数据库字段添加到上下文", dataMap.size());
}
```

#### 3. 标记原方法为过时

```java
/**
 * 将社区数据添加到上下文（已废弃，使用addMapDataToContext替代）
 * @deprecated 使用selectMaps查询和addMapDataToContext方法替代
 */
@Deprecated
private void addCommunityDataToContext(Map<String, Object> context, CommunityDisasterReductionCapacity communityData) {
    // 保留原有代码，以防万一需要回退
    ...
}
```

## 修复效果

### 优势

1. **完全配置化**：算法表达式中使用什么变量名，就直接对应数据库字段名
2. **无需硬编码**：不需要在代码中手动映射每个字段
3. **易于扩展**：添加新字段时只需在数据库和算法表达式中配置，无需修改代码
4. **类型安全**：自动将所有数值类型转换为 Double，避免整数除法精度丢失
5. **可维护性强**：代码量减少，逻辑清晰

### 变量名对应关系

现在算法表达式中的变量名直接对应数据库字段名：

| 算法表达式变量名 | 数据库字段名 | 实体类属性名 |
|----------------|-------------|-------------|
| `has_emergency_plan` | has_emergency_plan | hasEmergencyPlan |
| `has_vulnerable_groups_list` | has_vulnerable_groups_list | hasVulnerableGroupsList |
| `has_disaster_points_list` | has_disaster_points_list | hasDisasterPointsList |
| `has_disaster_map` | has_disaster_map | hasDisasterMap |
| `resident_population` | resident_population | residentPopulation |
| `last_year_funding_amount` | last_year_funding_amount | lastYearFundingAmount |
| `materials_equipment_value` | materials_equipment_value | materialsEquipmentValue |
| `medical_service_count` | medical_service_count | medicalServiceCount |
| `militia_reserve_count` | militia_reserve_count | militiaReserveCount |
| `registered_volunteer_count` | registered_volunteer_count | registeredVolunteerCount |
| `last_year_training_participants` | last_year_training_participants | lastYearTrainingParticipants |
| `last_year_drill_participants` | last_year_drill_participants | lastYearDrillParticipants |
| `emergency_shelter_capacity` | emergency_shelter_capacity | emergencyShelterCapacity |

## 测试验证

### 编译验证
```bash
mvn clean compile -DskipTests
# BUILD SUCCESS
```

### 功能测试步骤

1. 启动后端服务
2. 选择社区评估模型（modelId=4）
3. 执行社区评估
4. 查看评估结果，验证各指标赋值是否正确

### 预期结果

所有评估指标应该根据实际数据正确计算：
- 预案编制能力赋值：0 或 1
- 隐患排查能力赋值：0、0.5 或 1
- 风险评估能力赋值：0 或 1
- 财政投入能力赋值：> 0（根据实际数据）
- 物资储备能力赋值：> 0（根据实际数据）
- 医疗保障能力赋值：> 0（根据实际数据）
- 自救互救能力赋值：> 0（根据实际数据）
- 公众疏散能力赋值：> 0（根据实际数据）
- 转移安置能力赋值：> 0（根据实际数据）

## 影响范围

### 修改的文件
- `src/main/java/com/evaluate/service/impl/ModelExecutionServiceImpl.java`

### 修改的方法
1. 两处调用社区数据的地方（约 207-218 行和 1006-1016 行）
2. 新增 `addMapDataToContext` 通用方法（634-667 行）
3. 标记 `addCommunityDataToContext` 为 `@Deprecated`（675 行）

### 影响的功能
- 社区评估模型（modelId=4）的所有评估计算

## 后续建议

1. **乡镇模型也可以采用同样的方式**：将 `addSurveyDataToContext` 也改为使用 `selectMaps` 和 `addMapDataToContext`
2. **统一命名规范**：在算法配置文档中明确规定变量名必须使用数据库字段名（下划线命名）
3. **添加单元测试**：验证变量名映射和类型转换的正确性
4. **考虑性能优化**：如果需要频繁查询，可以考虑缓存机制

## 修复时间

- 2025-10-24

## 修复人员

- Claude Code
