# 乡镇聚合实现方案

## 需求
按乡镇分组求和，然后计算占比（乡镇内能力和值 / 乡镇内社区的数量）

## 当前状态
- 模型8步骤2已配置为"乡镇数据聚合"
- 但当前实现是按社区（region_code）循环执行的
- 步骤2的算法只是简单传递步骤1的输出

## 问题分析
当前的执行框架是按 `regionCodes` 列表循环的，每个 `regionCode` 代表一个社区。
要实现乡镇聚合，需要：
1. 识别哪些社区属于同一个乡镇（通过 `township_name` 字段）
2. 按乡镇分组
3. 对每个乡镇内的社区数据进行聚合计算

## 解决方案

### 方案1：前端聚合（推荐，最简单）
**优点**：
- 不需要修改后端逻辑
- 灵活，可以同时展示社区级和乡镇级数据
- 实现简单

**实现**：
1. 后端返回社区级别的完整数据（包含 township_name）
2. 前端按 township_name 分组聚合
3. 计算公式：`AVG(能力值) = SUM(社区能力值) / COUNT(社区数量)`

**前端示例代码**：
```javascript
// 按乡镇分组聚合
const townshipData = {};
results.forEach(row => {
  const township = row.township_name;
  if (!townshipData[township]) {
    townshipData[township] = {
      township_name: township,
      communities: [],
      plan_sum: 0,
      hazard_sum: 0,
      // ... 其他能力值
    };
  }
  townshipData[township].communities.push(row);
  townshipData[township].plan_sum += row.PLAN_CONSTRUCTION;
  townshipData[township].hazard_sum += row.HAZARD_INSPECTION;
  // ... 累加其他能力值
});

// 计算平均值
Object.values(townshipData).forEach(township => {
  const count = township.communities.length;
  township.plan_avg = township.plan_sum / count;
  township.hazard_avg = township.hazard_sum / count;
  // ... 计算其他平均值
});
```

### 方案2：后端聚合（复杂，需要大量修改）
**需要修改的地方**：
1. ModelExecutionServiceImpl.executeModel() - 添加乡镇识别逻辑
2. ModelExecutionServiceImpl.executeStep() - 支持按乡镇分组执行
3. 添加新的聚合算法标记（如 @GROUP_SUM, @GROUP_AVG）
4. SpecialAlgorithmServiceImpl - 实现聚合算法

**实现复杂度**：高
**维护成本**：高
**灵活性**：低（如果需要同时查看社区级和乡镇级数据会很困难）

### 方案3：混合方案（中等复杂度）
1. 保持当前的社区级别计算不变
2. 添加一个新的API端点专门用于乡镇级别聚合
3. 该端点调用社区级别的计算，然后在内存中进行聚合

**优点**：
- 不影响现有功能
- 可以同时支持社区级和乡镇级查询
- 相对容易实现

## 推荐方案
**方案1：前端聚合**

理由：
1. 最简单，不需要修改后端逻辑
2. 灵活性最高，可以同时展示多个层级的数据
3. 性能足够（社区数量不会太多）
4. 易于维护和扩展

## 当前配置
步骤2已配置为简单传递步骤1的输出：
- TOWNSHIP_PLAN_AGG = PLAN_CONSTRUCTION
- TOWNSHIP_HAZARD_AGG = HAZARD_INSPECTION
- TOWNSHIP_RISK_AGG = RISK_ASSESSMENT
- TOWNSHIP_FINANCIAL_AGG = FINANCIAL_INPUT
- TOWNSHIP_MATERIAL_AGG = MATERIAL_RESERVE
- TOWNSHIP_MEDICAL_AGG = MEDICAL_SUPPORT
- TOWNSHIP_AID_AGG = SELF_MUTUAL_AID
- TOWNSHIP_EVACUATION_AGG = PUBLIC_EVACUATION
- TOWNSHIP_SHELTER_AGG = RELOCATION_SHELTER

这样前端可以获取到完整的社区级别数据，然后自行聚合。

## 数据库字段
`community_disaster_reduction_capacity` 表包含：
- `region_code` - 社区代码（唯一标识）
- `township_name` - 乡镇名称（用于分组）
- `community_name` - 社区名称
- 其他原始数据字段...

## 下一步
如果选择方案1（推荐），需要：
1. 确保后端返回的数据包含 `township_name` 字段
2. 在前端实现按 `township_name` 分组聚合的逻辑
3. 展示乡镇级别的汇总数据

如果选择方案2或方案3，请告知，我可以继续实现后端聚合逻辑。
