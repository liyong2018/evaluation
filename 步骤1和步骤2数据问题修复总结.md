# 步骤1和步骤2数据问题修复总结

## 问题描述

### 问题1：步骤1只显示部分列
- **现象**：步骤1应该输出13列，但前端只显示了部分列（可能只有2-4列）
- **预期**：应该显示13列：
  1. Plan Construction（预案编制能力）
  2. Hazard Inspection（隐患排查能力）
  3. Risk Assessment（风险评估能力）
  4. Financial Input（资金投入能力）
  5. Material Reserve（物资储备能力）
  6. Medical Support（医疗保障能力）
  7. Self Mutual Aid（自救互救能力）
  8. Public Evacuation（公众疏散能力）
  9. Relocation Shelter（转移安置能力）
  10. Resident Population（常住人口）
  11. Funding Amount（资金投入总额）
  12. Materials Value（物资装备价值）
  13. Shelter Capacity（避难场所容量）

### 问题2：步骤2的聚合数据错误
- **现象**：Township Financial Aggregation 等字段的值异常大（如14021308）
- **原因**：`executeTownshipAggregation` 方法中调用了不存在的 `loadPreviousStepOutputs` 方法，导致无法正确加载步骤1的输出

## 修复内容

### 修复1：实现步骤1输出的加载逻辑
**文件**: `src/main/java/com/evaluate/service/impl/ModelExecutionServiceImpl.java`

**问题代码**：
```java
// 调用了不存在的方法
loadPreviousStepOutputs(communityContext, regionCode, inputData);
```

**修复后**：
```java
// 从inputData中获取步骤1的结果
for (Map.Entry<String, Object> entry : inputData.entrySet()) {
    String key = entry.getKey();
    if (key.startsWith("step_")) {
        Map<String, Object> stepResult = (Map<String, Object>) entry.getValue();
        Map<String, Map<String, Object>> regionResults = 
                (Map<String, Map<String, Object>>) stepResult.get("regionResults");
        
        if (regionResults != null && regionResults.containsKey(regionCode)) {
            // 将该社区在这个步骤的输出添加到上下文
            Map<String, Object> outputs = regionResults.get(regionCode);
            communityContext.putAll(outputs);
            log.debug("社区 {} 从 {} 加载了 {} 个输出", regionCode, key, outputs.size());
        }
    }
}
```

**说明**：
- 遍历 `inputData` 中所有以 "step_" 开头的键
- 从每个步骤的结果中提取当前社区的输出
- 将所有输出合并到 `communityContext` 中
- 这样就能正确获取步骤1的13个输出字段

### 修复2：关于步骤1列显示的问题

**可能的原因**：
1. **前端列配置问题**：前端可能只配置了部分列的显示
2. **列分组问题**：前端可能将步骤1的列分组隐藏了
3. **数据确实缺失**：后端可能没有返回所有13列

**验证方法**：
运行测试脚本 `test_step1_columns.ps1` 检查：
1. 后端返回的 `tableData[0]` 是否包含所有13个字段
2. 后端返回的 `columns` 数组是否包含所有13列的配置
3. 每列的 `stepOrder` 是否正确设置为1

**如果后端数据完整**：
- 问题在前端，需要检查前端的表格组件配置
- 可能需要修改前端代码以显示所有列

**如果后端数据不完整**：
- 检查步骤1的算法配置是否正确
- 检查 `executeStep` 方法是否正确执行了所有13个算法
- 检查 `generateResultTable` 方法是否正确收集了所有输出

## 数据流分析

### 步骤1：社区指标计算
```
输入: 社区原始数据（从 community_disaster_reduction_capacity 表）
  ↓
执行13个算法:
  1-9: 计算9个能力值（0-1之间的标准化值）
  10-13: 提取4个原始数据值
  ↓
输出: 13个字段
  - PLAN_CONSTRUCTION: 0.0 或 1.0
  - HAZARD_INSPECTION: 0.0, 0.5, 或 1.0
  - RISK_ASSESSMENT: 0.0 或 1.0
  - FINANCIAL_INPUT: 人均资金投入（元/人）
  - MATERIAL_RESERVE: 人均物资储备（元/人）
  - MEDICAL_SUPPORT: 人均医疗服务（个/万人）
  - SELF_MUTUAL_AID: 人均救援力量（人/万人）
  - PUBLIC_EVACUATION: 人均培训演练（人次/万人）
  - RELOCATION_SHELTER: 人均避难场所容量（人/人）
  - RESIDENT_POPULATION: 常住人口数
  - FUNDING_AMOUNT: 资金投入总额（万元）
  - MATERIALS_VALUE: 物资装备价值（万元）
  - SHELTER_CAPACITY: 避难场所容量（人）
```

### 步骤2：乡镇数据聚合
```
输入: 步骤1的13个字段（社区级别）
  ↓
按township_name分组:
  社区A: {PLAN_CONSTRUCTION: 1.0, FINANCIAL_INPUT: 0.5, ...}
  社区B: {PLAN_CONSTRUCTION: 0.0, FINANCIAL_INPUT: 0.3, ...}
  社区C: {PLAN_CONSTRUCTION: 1.0, FINANCIAL_INPUT: 0.4, ...}
  ↓
对每个字段求和并除以社区数量:
  PLAN_CONSTRUCTION = (1.0 + 0.0 + 1.0) / 3 = 0.667
  FINANCIAL_INPUT = (0.5 + 0.3 + 0.4) / 3 = 0.4
  ...
  ↓
输出: 9个能力值（乡镇平均值）
  - PLAN_CONSTRUCTION: 乡镇平均预案编制能力
  - HAZARD_INSPECTION: 乡镇平均隐患排查能力
  - RISK_ASSESSMENT: 乡镇平均风险评估能力
  - FINANCIAL_INPUT: 乡镇平均资金投入能力
  - MATERIAL_RESERVE: 乡镇平均物资储备能力
  - MEDICAL_SUPPORT: 乡镇平均医疗保障能力
  - SELF_MUTUAL_AID: 乡镇平均自救互救能力
  - PUBLIC_EVACUATION: 乡镇平均公众疏散能力
  - RELOCATION_SHELTER: 乡镇平均转移安置能力
```

## 预期结果

### 步骤1输出（社区级别）
| 社区代码 | Plan Construction | Hazard Inspection | ... | Resident Population |
|---------|-------------------|-------------------|-----|---------------------|
| 511425108001 | 1.0 | 0.5 | ... | 5000 |
| 511425108002 | 0.0 | 1.0 | ... | 3000 |
| 511425108003 | 1.0 | 0.5 | ... | 4000 |

**共13列**

### 步骤2输出（乡镇级别）
| 乡镇代码 | Plan Construction | Hazard Inspection | ... | Relocation Shelter |
|---------|-------------------|-------------------|-----|--------------------|
| TOWNSHIP_瑞峰镇 | 0.667 | 0.667 | ... | 0.5 |

**共9列**（只保留能力值，不包括原始数据）

## 测试步骤

### 1. 重启后端服务 ⚠️
**必须重启才能使修复生效！**

### 2. 运行测试脚本
```powershell
.\test_step1_columns.ps1
```

### 3. 验证结果
检查输出：
- ✅ 所有13个字段都存在
- ✅ 每个字段的值合理
- ✅ columns数组包含13列配置
- ✅ 步骤1的列标记为 stepOrder=1

### 4. 检查步骤2的数据
- ✅ Township Financial Aggregation 的值应该在合理范围内（0-1之间或小的正数）
- ✅ 所有9个聚合字段的值都是社区的平均值
- ✅ 只返回1行数据（乡镇级别）

## 故障排查

### 问题1：步骤1还是只显示部分列
**可能原因**：
1. 后端服务没有重启
2. 前端缓存问题
3. 前端列配置问题

**解决方法**：
1. 确认后端服务已重启
2. 清除浏览器缓存
3. 检查前端代码中的列配置

### 问题2：步骤2的数据还是错误
**可能原因**：
1. 后端服务没有重启
2. 步骤1的输出字段名不匹配
3. 聚合逻辑有问题

**解决方法**：
1. 确认后端服务已重启
2. 检查日志中是否有"社区 XXX 从 step_XXX 加载了 13 个输出"
3. 如果加载的输出数量不是13，说明步骤1的输出有问题

### 问题3：所有值都是0
**可能原因**：
1. 数据库中的原始数据为空
2. 步骤1的算法执行失败
3. 步骤2无法加载步骤1的输出

**解决方法**：
1. 检查数据库中的 `community_disaster_reduction_capacity` 表是否有数据
2. 检查后端日志中是否有算法执行错误
3. 检查日志中是否有"社区 XXX 从 step_XXX 加载了 X 个输出"

## 相关文件

- ✅ `ModelExecutionServiceImpl.java` - 后端代码（已修复）
- 📄 `test_step1_columns.ps1` - 测试脚本（新建）
- 📄 本文档 - 问题修复总结

## 下一步

1. ⚠️ **重启后端服务**（最重要！）
2. 🧪 运行 `test_step1_columns.ps1` 验证步骤1的13列数据
3. 🧪 运行 `test_township_aggregation.ps1` 验证步骤2的聚合数据
4. 📊 如果后端数据正确但前端显示不全，修改前端代码

## 技术要点

### 从inputData加载前序步骤输出
- `inputData` 中包含所有前序步骤的结果
- 键名格式：`"step_" + stepCode`
- 值格式：`{stepId, stepName, stepCode, regionResults: {regionCode: {output1, output2, ...}}}`
- 需要遍历所有步骤，提取当前社区的输出

### 聚合计算公式
```
乡镇能力平均值 = SUM(社区能力值) / 社区数量
```

**注意**：
- 分母是社区数量，不是有效值数量
- 即使某个社区的某个字段为null，也要计入社区数量
- 这样可以真实反映乡镇的整体能力水平
